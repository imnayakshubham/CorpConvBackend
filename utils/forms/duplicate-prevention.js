const getRedisInstance = require("../../redisClient/redisClient");

/**
 * @typedef {Object} DuplicatePreventionSettings
 * @property {boolean} enabled
 * @property {"ip"|"email"|"session"|"combined"} strategy
 * @property {"time-based"|"one-time"} mode
 * @property {number} timeWindow - Time window in minutes (only used for time-based mode)
 * @property {string} message - Error message when duplicate is detected
 * @property {boolean} [allowOverride]
 * @property {number} [maxAttempts]
 */

/**
 * @typedef {Object} DuplicateCheckResult
 * @property {boolean} isDuplicate
 * @property {string} message
 * @property {number} [timeRemaining] - Time remaining in seconds
 * @property {number} [attemptsRemaining]
 */

let redis = null;

/**
 * Get or create Redis client instance
 * @returns {import('ioredis').Redis}
 */
function getRedisClient() {
  if (!redis) {
    redis = getRedisInstance();
  }
  return redis;
}

/**
 * @type {DuplicatePreventionSettings}
 */
const DEFAULT_SETTINGS = {
  enabled: false,
  strategy: "combined", // Best strategy: combines IP, email, and session
  mode: "one-time", // Best mode: one-time submission
  timeWindow: 1440,
  message:
    "You have already submitted this form. Each user can only submit once.",
  allowOverride: false,
  maxAttempts: 1,
};

/**
 * Check if a submission is a duplicate
 * @param {string} formId - Form ID
 * @param {string} identifier - Unique identifier generated by generateIdentifier()
 * @param {DuplicatePreventionSettings} settings
 * @returns {Promise<DuplicateCheckResult>}
 */
async function checkDuplicateSubmission(
  formId,
  identifier,
  settings = DEFAULT_SETTINGS
) {
  if (!settings.enabled) {
    return {
      isDuplicate: false,
      message: "",
    };
  }

  const redis = getRedisClient();
  const key = `duplicate_prevention:${formId}:${identifier}`;

  try {
    // Check if submission exists
    const existingData = await redis.get(key);

    if (existingData) {
      const existingSubmission = JSON.parse(existingData);

      if (settings.mode === "one-time") {
        // One-time mode: never allow resubmission
        return {
          isDuplicate: true,
          message: settings.message,
        };
      }
      // Time-based mode: check time window
      const submissionData = existingSubmission;
      const timeWindowSeconds = settings.timeWindow * 60;
      const timeElapsed = Math.floor(
        (Date.now() - submissionData.timestamp) / 1000
      );
      const timeRemaining = timeWindowSeconds - timeElapsed;

      if (timeRemaining > 0) {
        const attemptsRemaining = Math.max(
          0,
          (settings.maxAttempts || 1) - submissionData.attempts
        );

        return {
          isDuplicate: true,
          message: settings.message,
          timeRemaining,
          attemptsRemaining,
        };
      }
      // Time window expired, remove the key
      await redis.del(key);
    }

    return {
      isDuplicate: false,
      message: "",
    };
  } catch (error) {
    console.error("Error checking duplicate submission:", error);
    // If Redis fails, allow submission to prevent blocking users
    return {
      isDuplicate: false,
      message: "",
    };
  }
}

/**
 * Record a submission to prevent duplicates
 * @param {string} formId - Form ID
 * @param {string} identifier - Unique identifier generated by generateIdentifier()
 * @param {DuplicatePreventionSettings} settings
 * @returns {Promise<void>}
 */
async function recordSubmission(
  formId,
  identifier,
  settings = DEFAULT_SETTINGS
) {
  if (!settings.enabled) {
    return;
  }

  const redis = getRedisClient();
  const key = `duplicate_prevention:${formId}:${identifier}`;

  try {
    const existingData = await redis.get(key);
    const existingSubmission = existingData ? JSON.parse(existingData) : null;

    if (existingSubmission) {
      if (settings.mode === "one-time") {
        // One-time mode: keep the existing record forever
        return;
      }
      // Time-based mode: update attempts
      const submissionData = existingSubmission;
      const timeWindowSeconds = settings.timeWindow * 60;
      const newAttempts = submissionData.attempts + 1;

      await redis.setex(
        key,
        timeWindowSeconds,
        JSON.stringify({
          timestamp: submissionData.timestamp,
          attempts: newAttempts,
        })
      );
    } else if (settings.mode === "one-time") {
      // One-time mode: store forever (no expiration)
      await redis.set(
        key,
        JSON.stringify({
          timestamp: Date.now(),
          attempts: 1,
        })
      );
    } else {
      // Time-based mode: store with expiration
      const timeWindowSeconds = settings.timeWindow * 60;
      await redis.setex(
        key,
        timeWindowSeconds,
        JSON.stringify({
          timestamp: Date.now(),
          attempts: 1,
        })
      );
    }
  } catch (error) {
    console.error("Error recording submission:", error);
  }
}

/**
 * Generate a unique identifier based on the strategy
 * @param {"ip"|"email"|"session"|"combined"} strategy
 * @param {string} ipAddress
 * @param {string} [email]
 * @param {string} [sessionId]
 * @returns {string}
 */
function generateIdentifier(strategy, ipAddress, email, sessionId) {
  switch (strategy) {
    case "ip":
      return `ip:${ipAddress}`;
    case "email":
      return email ? `email:${email.toLowerCase()}` : `ip:${ipAddress}`;
    case "session":
      return sessionId ? `session:${sessionId}` : `ip:${ipAddress}`;
    case "combined": {
      const parts = [`ip:${ipAddress}`];
      if (email) parts.push(`email:${email.toLowerCase()}`);
      if (sessionId) parts.push(`session:${sessionId}`);
      return parts.join("|");
    }
    default:
      return `ip:${ipAddress}`;
  }
}

/**
 * Extract email from submission data
 * Looks for common email field names
 * @param {Record<string, unknown>} submissionData
 * @returns {string|undefined}
 */
function extractEmailFromSubmissionData(submissionData) {
  // Look for common email field names
  const emailFields = [
    "email",
    "e-mail",
    "mail",
    "user_email",
    "contact_email",
  ];

  for (const field of emailFields) {
    if (submissionData[field] && typeof submissionData[field] === "string") {
      const email = submissionData[field].trim().toLowerCase();
      // Basic email validation
      if (email.includes("@") && email.includes(".")) {
        return email;
      }
    }
  }

  return undefined;
}

/**
 * Format time remaining in human-readable format
 * @param {number} seconds
 * @returns {string}
 */
function formatTimeRemaining(seconds) {
  if (seconds < 60) {
    return `${seconds} seconds`;
  }
  if (seconds < 3600) {
    const minutes = Math.ceil(seconds / 60);
    return `${minutes} minute${minutes > 1 ? "s" : ""}`;
  }
  if (seconds < 86400) {
    const hours = Math.ceil(seconds / 3600);
    return `${hours} hour${hours > 1 ? "s" : ""}`;
  }
  const days = Math.ceil(seconds / 86400);
  return `${days} day${days > 1 ? "s" : ""}`;
}

module.exports = {
  checkDuplicateSubmission,
  recordSubmission,
  generateIdentifier,
  extractEmailFromSubmissionData,
  formatTimeRemaining,
  DEFAULT_SETTINGS,
  getRedisClient,
};
