const express = require('express');
const router = express.Router();
const { authenticateToken, optionalAuth } = require('../middleware/auth');
const { body, param, query, validationResult } = require('express-validator');

const {
  createSurvey,
  listSurveys,
  archiveSurvey,
  editSurvey,
  getSurvey,
  surveySubmission,
  getSurveySubmission,
  duplicateSurvey,
  togglePublishStatus,
  getSurveyAnalytics,
  createFormLimit,
  submitFormLimit
} = require('../controllers/surveyController');

// Validation middleware helper
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: 'Validation failed',
      details: errors.array()
    });
  }
  next();
};

// Validation rules that work with both old and new formats
const validateSurveyCreate = [
  body(['survey_title', 'title'])
    .optional()
    .trim()
    .isLength({ min: 3, max: 100 })
    .withMessage('Title must be between 3 and 100 characters'),
  body(['survey_description', 'description'])
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must be less than 1000 characters'),
  body(['survey_form', 'fields'])
    .optional()
    .isArray()
    .withMessage('Fields must be an array'),
  body('status')
    .optional()
    .isIn(['draft', 'published', 'archived'])
    .withMessage('Invalid status'),
  // Custom validation to ensure at least one title field is present
  body()
    .custom((value) => {
      if (!value.survey_title && !value.title) {
        throw new Error('Title is required (survey_title or title)');
      }
      return true;
    })
];

const validateSubmission = [
  body(['submissions', 'data'])
    .custom((value) => {
      if (!value) {
        throw new Error('Submission data is required (submissions or data)');
      }
      return true;
    }),
  body('sessionId')
    .optional()
    .isString()
    .withMessage('Session ID must be a string')
];

// ============ ORIGINAL ROUTES (Backward Compatible) ============

// CREATE Survey - supports both old and new format
router.post('/create',
  authenticateToken,
  createFormLimit,
  validateSurveyCreate,
  handleValidationErrors,
  createSurvey
);

// LIST Surveys - enhanced with optional pagination info
router.get('/list',
  authenticateToken,
  [
    query('page').optional().isInt({ min: 1 }),
    query('limit').optional().isInt({ min: 1, max: 100 }),
    query('status').optional().isIn(['draft', 'published', 'archived']),
    query('showAll').optional().isBoolean(),
    query('search').optional().isString(),
    query('sortBy').optional().isIn(['title', 'views', 'submissions', 'created', 'updated']),
    query('sortOrder').optional().isIn(['asc', 'desc']),
    handleValidationErrors
  ],
  listSurveys
);

// GET single survey by ID
router.get('/get/:id',
  authenticateToken,
  [
    param('id').isString().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  getSurvey
);

// EDIT Survey - supports both field formats
router.put('/edit/:id',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    ...validateSurveyCreate,
    handleValidationErrors
  ],
  editSurvey
);

// ARCHIVE Survey (soft delete)
router.delete('/archive/:id',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  archiveSurvey
);

// SUBMIT Survey Response
router.post('/submit/:id',
  authenticateToken,
  submitFormLimit,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    ...validateSubmission,
    handleValidationErrors
  ],
  surveySubmission
);

// GET Survey Submissions
router.get('/submissions/:id',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  getSurveySubmission
);

// ============ NEW ROUTES (RESTful format for new implementations) ============

// RESTful routes that mirror the new forms API structure
// These routes provide the same functionality but with RESTful conventions

// GET /api/surveys - List surveys (RESTful version)
router.get('/',
  authenticateToken,
  [
    query('page').optional().isInt({ min: 1 }),
    query('limit').optional().isInt({ min: 1, max: 100 }),
    query('status').optional().isIn(['draft', 'published', 'archived']),
    handleValidationErrors
  ],
  async (req, res) => {
    // Set flag to include pagination in response
    req.query.includePagination = 'true';
    return listSurveys(req, res);
  }
);

// POST /api/surveys - Create survey (RESTful version)
router.post('/',
  authenticateToken,
  createFormLimit,
  validateSurveyCreate,
  handleValidationErrors,
  createSurvey
);

// GET /api/surveys/:id - Get specific survey
router.get('/:id',
  authenticateToken,
  [
    param('id').isString().withMessage('Invalid survey identifier'),
    handleValidationErrors
  ],
  getSurvey
);

// PUT /api/surveys/:id - Update survey (RESTful version)
router.put('/:id',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    ...validateSurveyCreate,
    handleValidationErrors
  ],
  editSurvey
);

// DELETE /api/surveys/:id - Delete/Archive survey (RESTful version)
router.delete('/:id',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  archiveSurvey
);

// ============ NEW ENHANCED FEATURES ============

// GET /api/surveys/slug/:slug - Get survey by slug (public access)
router.get('/slug/:slug',
  optionalAuth, // Optional auth for public forms
  [
    param('slug').isString().isLength({ min: 1 }).withMessage('Invalid slug'),
    handleValidationErrors
  ],
  async (req, res) => {
    // Override the ID param with slug for getSurvey function
    req.params._id = req.params.slug;
    return getSurvey(req, res);
  }
);

// POST /api/surveys/:id/duplicate - Duplicate a survey
router.post('/:id/duplicate',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  duplicateSurvey
);

// PUT /api/surveys/:id/publish - Toggle publish status
router.put('/:id/publish',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    body('isPublished').isBoolean().withMessage('isPublished must be a boolean'),
    handleValidationErrors
  ],
  togglePublishStatus
);

// POST /api/surveys/:id/submit - Submit survey (public endpoint)
router.post('/:id/submit',
  optionalAuth, // Make auth optional for public forms
  submitFormLimit,
  [
    param('id').isString().withMessage('Invalid survey identifier'),
    ...validateSubmission,
    handleValidationErrors
  ],
  surveySubmission
);

// GET /api/surveys/:id/analytics - Get survey analytics
router.get('/:id/analytics',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  getSurveyAnalytics
);

// GET /api/surveys/:id/submissions - Get submissions (RESTful version)
router.get('/:id/submissions',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    query('page').optional().isInt({ min: 1 }),
    query('limit').optional().isInt({ min: 1, max: 100 }),
    handleValidationErrors
  ],
  getSurveySubmission
);

// GET /api/surveys/:id/verify-ownership - Verify survey ownership
router.get('/:id/verify-ownership',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      const Survey = require('../models/surveyModel').Survey;
      const survey = await Survey.findOne({
        _id: req.params._id,
        $or: [
          { created_by: req.user._id },
          { userId: req.user._id }
        ]
      }).select('_id');

      return res.json({
        success: true,
        data: {
          isOwner: !!survey
        }
      });
    } catch (error) {
      console.error('Error verifying survey ownership:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to verify ownership'
      });
    }
  }
);

// ============ BULK OPERATIONS (New Features) ============

// POST /api/surveys/bulk/delete - Bulk delete surveys
router.post('/bulk/delete',
  authenticateToken,
  [
    body('surveyIds').isArray().withMessage('Survey IDs must be an array'),
    body('surveyIds.*').isMongoId().withMessage('Invalid survey ID in array'),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      const { surveyIds } = req.body;
      const Survey = require('../models/surveyModel').Survey;

      // Only delete surveys owned by the user
      const result = await Survey.updateMany(
        {
          _id: { $in: surveyIds },
          $or: [
            { created_by: req.user._id },
            { userId: req.user._id }
          ]
        },
        {
          status: 'archived',
          access: false
        }
      );

      return res.json({
        success: true,
        message: `${result.modifiedCount} surveys archived successfully`,
        data: {
          modified: result.modifiedCount,
          requested: surveyIds.length
        }
      });
    } catch (error) {
      console.error('Bulk delete error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to archive surveys'
      });
    }
  }
);

// POST /api/surveys/bulk/update-status - Bulk update survey status
router.post('/bulk/update-status',
  authenticateToken,
  [
    body('surveyIds').isArray().withMessage('Survey IDs must be an array'),
    body('surveyIds.*').isMongoId().withMessage('Invalid survey ID in array'),
    body('status').isIn(['draft', 'published', 'archived']).withMessage('Invalid status'),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      const { surveyIds, status } = req.body;
      const Survey = require('../models/surveyModel').Survey;

      const updateData = { status };
      if (status === 'published') {
        updateData.access = true;
      } else if (status === 'archived') {
        updateData.access = false;
      }

      const result = await Survey.updateMany(
        {
          _id: { $in: surveyIds },
          $or: [
            { created_by: req.user._id },
            { userId: req.user._id }
          ]
        },
        updateData
      );

      return res.json({
        success: true,
        message: `${result.modifiedCount} surveys updated successfully`,
        data: {
          modified: result.modifiedCount,
          requested: surveyIds.length,
          newStatus: status
        }
      });
    } catch (error) {
      console.error('Bulk update status error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to update survey status'
      });
    }
  }
);

// ============ EXPORT/IMPORT FEATURES ============

// GET /api/surveys/:id/export - Export survey structure
router.get('/:id/export',
  authenticateToken,
  [
    param('id').isMongoId().withMessage('Invalid survey ID'),
    query('format').optional().isIn(['json', 'csv']).withMessage('Invalid format'),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      const Survey = require('../models/surveyModel').Survey;
      const survey = await Survey.findOne({
        _id: req.params._id,
        $or: [
          { created_by: req.user._id },
          { userId: req.user._id }
        ]
      });

      if (!survey) {
        return res.status(404).json({
          success: false,
          error: 'Survey not found'
        });
      }

      const format = req.query.format || 'json';

      if (format === 'json') {
        // Remove sensitive data before export
        const exportData = survey.toObject();
        delete exportData._id;
        delete exportData.submissions;
        delete exportData.created_by;
        delete exportData.userId;
        delete exportData.__v;

        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition',
          `attachment; filename="survey-${survey.slug || survey?._id}.json"`);

        return res.json(exportData);
      } else if (format === 'csv') {
        // Export submissions as CSV
        const Submission = require('../models/surveyModel').Submission;
        const submissions = await Submission.find({ survey_id: req.params._id });

        // Convert to CSV format (simplified example)
        const csv = submissions.map(sub => {
          return JSON.stringify(sub.submissions);
        }).join('\n');

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition',
          `attachment; filename="submissions-${survey.slug || survey?._id}.csv"`);

        return res.send(csv);
      }
    } catch (error) {
      console.error('Export error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to export survey'
      });
    }
  }
);

// POST /api/surveys/import - Import survey structure
router.post('/import',
  authenticateToken,
  [
    body('surveyData').isObject().withMessage('Survey data must be an object'),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      const Survey = require('../models/surveyModel').Survey;
      const importData = req.body.surveyData;

      // Add user ownership
      importData.created_by = req.user._id;
      importData.userId = req.user._id;

      // Reset some fields
      delete importData._id;
      delete importData.slug;
      importData.submissions = [];
      importData.status = 'draft';
      importData.view_count = 0;
      if (importData.analytics) {
        importData.analytics = {
          totalViews: 0,
          totalSubmissions: 0,
          conversionRate: 0
        };
      }

      // Add (Imported) to title
      if (importData.survey_title) {
        importData.survey_title = `${importData.survey_title} (Imported)`;
      }

      const newSurvey = new Survey(importData);
      await newSurvey.save();

      return res.status(201).json({
        success: true,
        message: 'Survey imported successfully',
        data: newSurvey
      });
    } catch (error) {
      console.error('Import error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to import survey',
        details: error.message
      });
    }
  }
);

// ============ TEMPLATE FEATURES ============

// GET /api/surveys/templates - Get survey templates
router.get('/templates/list',
  [
    query('category').optional().isString(),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      // Return predefined templates
      const templates = [
        {
          id: 'customer-feedback',
          name: 'Customer Feedback',
          category: 'feedback',
          description: 'Gather customer satisfaction feedback',
          fields: [
            {
              type: 'radio',
              label: 'How satisfied are you with our service?',
              options: ['Very Satisfied', 'Satisfied', 'Neutral', 'Dissatisfied', 'Very Dissatisfied'],
              required: true
            },
            {
              type: 'textarea',
              label: 'Additional comments',
              placeholder: 'Tell us more...',
              required: false
            }
          ]
        },
        {
          id: 'event-registration',
          name: 'Event Registration',
          category: 'registration',
          description: 'Collect event registration information',
          fields: [
            {
              type: 'text',
              label: 'Full Name',
              required: true
            },
            {
              type: 'email',
              label: 'Email Address',
              required: true
            },
            {
              type: 'phone',
              label: 'Phone Number',
              required: false
            }
          ]
        }
      ];

      const filteredTemplates = req.query.category ?
        templates.filter(t => t.category === req.query.category) :
        templates;

      return res.json({
        success: true,
        data: filteredTemplates
      });
    } catch (error) {
      console.error('Get templates error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch templates'
      });
    }
  }
);

// POST /api/surveys/from-template - Create survey from template
router.post('/from-template',
  authenticateToken,
  [
    body('templateId').isString().withMessage('Template ID is required'),
    body('title').optional().isString(),
    handleValidationErrors
  ],
  async (req, res) => {
    try {
      // This would fetch the template and create a survey
      // For now, we'll create a basic survey based on templateId
      req.body.survey_title = req.body.title || `New Survey from Template`;
      req.body.status = 'draft';

      // Add template fields based on templateId
      // This is simplified - you'd normally fetch from a templates collection

      return createSurvey(req, res);
    } catch (error) {
      console.error('Create from template error:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to create survey from template'
      });
    }
  }
);

module.exports = router;